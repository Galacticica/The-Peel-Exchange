{% extends "base.html" %}

{% block content %}

<div class="flex items-start justify-center">
	<div class="w-full max-w-3xl">
		<div class="card bg-base-200 shadow-md p-6">
			<h2 class="text-2xl font-bold mb-4">Market ‚Äî Choose a stock</h2>

		<div class="mb-4">
			<label class="block text-sm font-medium text-base-content mb-2">Stock</label>
			<div class="flex flex-col sm:flex-row gap-2 items-stretch sm:items-center">
				<select id="sort-select" class="select select-bordered w-full sm:w-60">
					<option value="symbol_asc">Symbol (A ‚Üí Z)</option>
					<option value="symbol_desc">Symbol (Z ‚Üí A)</option>
					<option value="price_desc">Price (High ‚Üí Low)</option>
					<option value="price_asc">Price (Low ‚Üí High)</option>
				</select>
				<select id="stock-select" class="select select-bordered flex-1">
				</select>
			</div>
		</div>			
		<div id="stock-card" class="p-4 rounded-lg bg-base-100 shadow-sm">
			<div class="flex flex-col sm:flex-row sm:items-baseline sm:justify-between gap-2">
				<div>
					<div id="stock-name" class="text-lg font-semibold">&nbsp;</div>
					<div id="stock-symbol" class="text-sm text-muted">&nbsp;</div>
				</div>
				<div class="sm:text-right">
					<div class="text-sm text-muted">Current Price</div>
					<div id="stock-price" class="text-2xl font-mono">&nbsp;</div>
				</div>
			</div>			<div class="mt-4">
				<div class="relative w-full" style="height: 250px;">
					<canvas id="price-chart" class="w-full h-full"></canvas>
				</div>
			</div>				<div class="mt-4 grid grid-cols-1 sm:grid-cols-3 gap-3 items-end">
					<div class="col-span-2">
						<label class="block text-sm text-muted mb-1">Quantity</label>
						<input id="buy-amount" type="number" min="1" value="1" class="input input-bordered w-full" />
					</div>
					<div>
						<button id="buy-btn" class="btn btn-primary w-full">Buy</button>
					</div>
				</div>

				<div id="buy-msg" class="mt-3 text-sm"></div>
			</div>

		</div>
	</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(function(){
		const listUrl = '/api/stocks/';
    const detailUrl = (s) => `/api/stocks/${encodeURIComponent(s)}/`;
    const historyUrl = (s) => `/api/stocks/${encodeURIComponent(s)}/history/`;
    	const buyUrl = '/api/buy/';
    	const select = document.getElementById('stock-select');
		const sortSelect = document.getElementById('sort-select');
    	const nameEl = document.getElementById('stock-name');
    	const symbolEl = document.getElementById('stock-symbol');
    	const priceEl = document.getElementById('stock-price');
    		const amountEl = document.getElementById('buy-amount');
    	const buyBtn = document.getElementById('buy-btn');
    	const buyMsg = document.getElementById('buy-msg');

		let msgTimeout = null;

		function scheduleClear(){
			if(msgTimeout) clearTimeout(msgTimeout);
			msgTimeout = setTimeout(()=>{
				buyMsg.textContent = '';
				buyMsg.className = 'mt-3 text-sm';
				msgTimeout = null;
			}, 5000);
		}

	let currentSymbol = null;
	let pollHandle = null;
	let historyHandle = null;
	let priceChart = null;
	let cachedStocks = null; 

	function sortStocks(list, mode){
		if(!Array.isArray(list)) return list;
		const copy = list.slice();
		switch(mode){
			case 'symbol_asc':
				copy.sort((a,b) => a.symbol.localeCompare(b.symbol));
				break;
			case 'symbol_desc':
				copy.sort((a,b) => b.symbol.localeCompare(a.symbol));
				break;
			case 'price_desc':
				copy.sort((a,b) => (b.price||0) - (a.price||0));
				break;
			case 'price_asc':
				copy.sort((a,b) => (a.price||0) - (b.price||0));
				break;
			default:
				copy.sort((a,b) => a.symbol.localeCompare(b.symbol));
		}
		return copy;
	}

	function fmtPrice(p){ return `${(p).toFixed(2)} üçå`; }

	async function fetchStocks(){
		try{
			const res = await fetch(listUrl, {cache: 'no-store'});
			if(!res.ok) throw new Error('Failed to load stocks');
			const stocks = await res.json();
			cachedStocks = stocks;
			const mode = sortSelect ? sortSelect.value : 'symbol_asc';
			populateSelect(sortStocks(stocks, mode));
		}catch(e){
			console.error('fetchStocks', e);
		}
	}

	function populateSelect(stocks){
		if(!Array.isArray(stocks)) stocks = [];
		const existing = Array.from(select.options).map(o => o.value);
		const newSymbols = stocks.map(s => s.symbol);
		if(JSON.stringify(existing) === JSON.stringify(newSymbols)) return;

		// remember currently selected symbol so we can try to preserve selection when resorting
		const previous = select.value;

		select.innerHTML = '';
		stocks.forEach((s, idx) => {
			const opt = document.createElement('option');
			opt.value = s.symbol;
			opt.textContent = `${s.name} (${s.symbol})`;
			select.appendChild(opt);
		});

		// try to keep previous selection if it's still present
		if(previous && newSymbols.includes(previous)){
			select.value = previous;
			currentSymbol = previous;
			updateDetail(currentSymbol);
		} else if(!currentSymbol && stocks.length>0){
			select.value = stocks[0].symbol;
			currentSymbol = stocks[0].symbol;
			updateDetail(currentSymbol);
		} else if(currentSymbol){
			// keep currentSymbol but ensure the select's value reflects it if present
			if(newSymbols.includes(currentSymbol)) select.value = currentSymbol;
			else if(stocks.length>0){ select.value = stocks[0].symbol; currentSymbol = stocks[0].symbol; updateDetail(currentSymbol); }
		}
	}

	async function updateDetail(symbol){
		if(!symbol) return;
		try{
			const res = await fetch(detailUrl(symbol), {cache: 'no-store'});
			if(!res.ok) throw new Error('Failed to load stock detail');
			const d = await res.json();
			nameEl.textContent = d.name || '';
			symbolEl.textContent = d.symbol || '';
			priceEl.textContent = d.price!==undefined ? fmtPrice(d.price) : '';
			updateHistory(symbol);
		}catch(e){
			console.error('updateDetail', e);
		}
	}

	async function updateHistory(symbol){
		if(!symbol) return;
		try{
			const res = await fetch(historyUrl(symbol), {cache: 'no-store'});
			if(!res.ok) throw new Error('Failed to load history');
			const h = await res.json();
			const labels = h.map(item => new Date(item.timestamp).toLocaleString());
			const data = h.map(item => item.price);
			const ctx = document.getElementById('price-chart').getContext('2d');
			if(!priceChart){
				// Check if screen is mobile size
				const isMobile = window.innerWidth < 640;
				
				priceChart = new Chart(ctx, {
					type: 'line',
					data: { 
						labels: labels, 
						datasets: [{ 
							label: 'Price', 
							data: data, 
							borderColor: '#10b981', 
							backgroundColor: 'rgba(16,185,129,0.08)', 
							tension: 0.3,
							borderWidth: 2,
							pointRadius: isMobile ? 2 : 3,
							pointHoverRadius: isMobile ? 4 : 6
						}] 
					},
					options: { 
						responsive: true, 
						maintainAspectRatio: false,
						interaction: {
							mode: 'index',
							intersect: false
						},
						plugins: { 
							legend: {
								display: false
							},
							tooltip: { 
								mode: 'index', 
								intersect: false,
								callbacks: {
									label: function(context) {
										return 'Price: ' + context.parsed.y.toFixed(2) + ' üçå';
									}
								}
							}
						}, 
						scales: { 
							x: { 
								display: true,
								ticks: {
									maxRotation: isMobile ? 45 : 0,
									minRotation: isMobile ? 45 : 0,
									autoSkip: true,
									maxTicksLimit: isMobile ? 4 : 8,
									font: {
										size: isMobile ? 9 : 11
									}
								},
								grid: {
									display: false
								}
							}, 
							y: { 
								display: true, 
								ticks: { 
									callback: v => v.toFixed(2) + ' üçå',
									maxTicksLimit: isMobile ? 5 : 7,
									font: {
										size: isMobile ? 10 : 11
									}
								},
								grid: {
									color: 'rgba(0, 0, 0, 0.05)'
								}
							} 
						} 
					}
				});
			} else {
				priceChart.data.labels = labels;
				priceChart.data.datasets[0].data = data;
				priceChart.update();
			}
		}catch(e){
			console.error('updateHistory', e);
		}
	}


		function getCookie(name) {
			let cookieValue = null;
			if (document.cookie && document.cookie !== '') {
				const cookies = document.cookie.split(';');
				for (let i = 0; i < cookies.length; i++) {
					const cookie = cookies[i].trim();
					if (cookie.substring(0, name.length + 1) === (name + '=')) {
						cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
						break;
					}
				}
			}
			return cookieValue;
		}

		async function buyCurrent(){
			const symbol = currentSymbol;
			const amount = parseInt(amountEl.value, 10) || 0;
			buyMsg.textContent = '';
			if(!symbol) return;
			if(amount < 1){ buyMsg.textContent = 'Enter a quantity of 1 or more.'; buyMsg.className = 'mt-3 text-sm text-red-700'; scheduleClear(); return; }

			try{
				const res = await fetch(buyUrl, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'X-CSRFToken': getCookie('csrftoken')
					},
					body: JSON.stringify({ symbol, amount })
				});

				const body = await res.json();
						if(!res.ok){
							buyMsg.textContent = body.error || 'Purchase failed';
							buyMsg.className = 'mt-3 text-sm text-red-700';
							scheduleClear();
							return;
						}

				buyMsg.textContent = `Bought ${body.holding.shares} ${body.holding.symbol} ‚Äî new balance ${Number(body.balance).toFixed(2)} üçå`;
				buyMsg.className = 'mt-3 text-sm text-green-800';
				scheduleClear();
				updateDetail(symbol);
				}catch(e){
					console.error('buyCurrent', e);
					buyMsg.textContent = 'Purchase failed (network)';
					buyMsg.className = 'mt-3 text-sm text-red-700';
					scheduleClear();
				}
		}

		buyBtn.addEventListener('click', ()=> buyCurrent());

	select.addEventListener('change', (e)=>{
		const s = e.target.value;
		currentSymbol = s;
		updateDetail(s);
		if(pollHandle) clearInterval(pollHandle);
		pollHandle = setInterval(()=> updateDetail(currentSymbol), 5000);
		if(historyHandle) clearInterval(historyHandle);
		historyHandle = setInterval(()=> updateHistory(currentSymbol), 5000);
	});

	if(sortSelect){
		sortSelect.addEventListener('change', ()=>{
			const mode = sortSelect.value;
			const list = cachedStocks ? sortStocks(cachedStocks, mode) : [];
			populateSelect(list);
		});
	}
	document.addEventListener('DOMContentLoaded', ()=>{
		fetchStocks();
		pollHandle = setInterval(()=>{
			if(currentSymbol) updateDetail(currentSymbol);
			else fetchStocks();
		}, 5000);

		historyHandle = setInterval(()=>{
			if(currentSymbol) updateHistory(currentSymbol);
		}, 5000);
	});

})();
</script>

{% endblock %}